= абстракция хранилища
- большие объемы
- быстрый поиск
- быстрая модификация
- методы CRUD create read update delete

= задача поиска
bunch a;
index = a.find(key)

= разместить элемент который ищется за последним
по порядку в хранилище - в два раза меньше операций 
сравнения, не сравниваем индекс
(в случае если элемента нет мы возвращаем индекс за последним)

= неупорядоченный массив
C - 1; R - N; U - N; D - N

= ПОИСК С СУЖЕНИЕМ ЗОНЫ

int binarySearch(int val, int a[], int left, int right) {
  
  if (left >= right) return a[left] == val? left : -1;
    int mid = (left+right)/2;
  
  if (a[mid] == val) return mid;
  
  if (a[mid] < val) {
    return binarySearch(val, a, left, mid-1);
  } else {
    return binarySearch(val, a, mid+1, right);
  }
}

int binarySearch(int val, int a[], int left, int right) {
  
  while (left < right) {                // 1st cmp
    int mid = (left + right)/2;
    
    if (a[mid] == val) return mid;      // 2nd cmp
  
    if (a[mid] < val) {                 // 3rd cmp
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return a[left] == val? left : -1;
}

T(N) = logN

= упорядоченный массив
C - N; R - logN; U - N; D - N

= РАСПРЕДЕЛЯЮЩИЙ ПОИСК
C - N; R - 1; U - 1(?); D - 1(?)

найти сразу M элементов
быстрее O(N) в неотсортированном? - нет

подготовка - создание 'инвертированного' массива

int min, max;
int *ainv = prepare(a, N, &min, &max);

if (ainv != nullptr) {
  // Поиск ключа key
  result = -1;
  if (key >= min && key <= max) result = ainv[key - min];
  ...
  delete [] ainv;
} else {
  // Какой-то другой поиск.
}

= ОДНОСВЯЗНЫЙ СПИСОК 
- для быстро изменяющихся данных
(без tail, size)

insert: after - 1, before - N, tofront - 1, toback - N, 
find - N, size - N

toback, before - перебор с головы

чтобы не поддерживать актуальное значение 
головы - удобно держать ее отдельно - фиктивный head

= ДВУСВЯЗНЫЙ СПИСОК
- для ускорения симметричных операций

insert: after - 1, before - 1, tofront - 1, toback - 1, 
find - N, size - N

= ОЧЕРЕДЬ (FIFO)
- может быть реализована на списке

create, delete, 
enqueue - добавить в конец
dequeue - удалить из начала
empty - пуста ли

= СТЕК (LIFO)

= ДЕРЕВО
(дерево 1-ричного порядка - список)
- вершины - листья и узлы - имеют детей
- глубина вершины - от нее до корня + 1

- вместо работы с памятью в куче, используем заранее
заготовленную память в массиве 
узлы нумеруются - с 0: NK+1, ..., NK+N
                  с 1: (N=2) 2K, 2K+1 
        (умножение/деление на два с помощью сдвигов)

- представление в виде массива эффективно для ПЛОТНЫХ деревьев

= ОБХОД

- прямой - NLR
- симметричный - LNR
- обратный - LRN
- обратно симметричный - RNL

= ПОЛНОЕ БИНАРНОЕ ДЕРЕВО
путь до любой вершины одинаков, у узлов оба потомка
N = 2^(H+1) - 1; H = log2(N+1)

= ПРИОРИТЕТНАЯ ОЧЕРЕДЬ
порядок извлечения определяется приоритетом
первым извлекается наиболее приоритетный

insert, fetch, extract

представление в виде упорядоченного массива - 
дорого - вставка за N (см выше)

= БИНАРНАЯ КУЧА - ПИРАМИДА - HEAP

бинарное дерево: 
1. приоритет любой node не меньше приоритета потомка
2. правильное подмножество полного бинарного, допускающего 
   плотное хранение узлов в массиве

корень - индекс 1
родитель - i/2
left - 2i, right - 2i+1

(нулевой элемент не используем для удобства)

create - N; fetch - 1;

- insert - O(logN) 
поддерживаем 1) структуру бинарного дерева 
             2) приоритетность

int binary_heap::insert(bhnode node) {
  
  if (numnodes > bodysize) {
    return -1; // или расширяем.
  }

  body[++numnodes] = node;
  
  for (int i = numnodes; 
           i > 1 && body[i].priority > body[i/2].priority;
           i /= 2) {
    swap(i, i/2);
  }
}

- heapify - O(logN) 

void binary_heap::heapify(int index) {
  
  for (;;) {
    
    int left = index + index;
    int right = left + 1;
    
    // Кто больше, [index], [left], [right]?
    
    int largest = index;
    if (left <= numnodes && body[left].priority > body[index].priority)
      largest = left;

    if (right <= numnodes && body[right].priority > body[largest].priority)
      largest = right;
    
    if (largest == index) break;
    
    swap(index, largest);
    index = largest;
  }
}

= HEAPSORT
- O(NlogN) in worst case
- quickSort have less operations with memory compared to heapSort
- quickSort is more cache-friendly 

- allocate heap - O(N)
- вставить N элементов - O(NlogN) (buildHeap - Heapify N/2 times)
- fetch and delete - O(NlogN)

void heapify(int *a, int i, int n) // in-place version for ay array
{
  int curr = a[i];
  int index = i;
  
  for (;;) {
    int left = index + index + 1;
    int right = left + 1;
    
    if ( left < n && a[left] > curr)
      index = left;
    
    if ( right < n && a[right] > a[index])
      index = right;
    
    if (index == i ) break;
    
    a[i] = a[index];
    a[index] = curr;
    i = index;
  }
}

with this version:
- no allocate 
- вставить N элементов - O(NlogN) (buildHeap - Heapify N/2 times)
- fetch and delete - O(NlogN)

