= array - мнво ключей - индексов -> мнво эл-тов O(1)
= mapping - обобщение мн-ва индексов до произвольных величин

= АБСТРАКЦИЯ ОТОБРАЖЕНИЕ
- аналог дискретной функции
- устанаваливает направленное соответствие между 
мн-вами ключей и данных

map m<string,int>;
m["Шанхай"] = 24150000;
m["Карачи"] = 23500000;
m["Пекин"] = 21150000;
m["Дели"] = 17830000;
...
int BeijingPopulation = m["Пекин"];
...
for (auto x: m) {
  printf("Population of ’%s’ is %d\n",
  x.first, x.second);
}

- insert(key, value) — добавить элемент с ключом key и значением
value.
- Item find(key) — найти элемент с ключом key и вернуть его.
- erase(key) — удалить элемент с ключом key.
- walk — получить все ключи (или все пары ключ/значение) в какомлибо порядке.

= АБСТРАКЦИЯ МНОЖЕСТВО
- можно абстрагировать понятие множество как отображение набора 
ключей на логические переменные: все присутствующие в множестве элементы
отображаются на логическую истину, остальные — на логическую ложь.

= BST
- Бинарным деревом поиска называется бинарное дерево, в котором 
все узлы, находящиеся справа от родителя, имеют значения, не меньшие 
значения в родительском узле, а слева — не большие
этого значения.

Алгоритм поиска элемента в BST, содержащего ключ X.
1. Делаем текущий узел корневым.
2. Переходим в текущий узел C.
3. Если X = C.Key, то алгоритм завершён.
4. Если X > C.Key и C имеет потомка справа, то делаем текущим узлом
потомка справа. Переходим к п. 2.
5. Если X < C.Key и C имеет потомка слева, то делаем текущим узлом
потомка слева. Переходим к п. 2.
6. Ключ не найден. Конец алгоритма

Алгоритм вставки элемента элемента с ключом X в BST.
1. Делаем текущий узел корневым.
2. Переходим в текущий узел C.
3. Если X = C.Key, то алгоритм завершён, вставка невозможна.
4. Если X > C.Key и C имеет потомка справа, то делаем текущим узлом
потомка справа. Переходим к п. 2.
5. Если X > C.Key и C потомка справа не имеет, то создаём правого
потомка с ключом X и завершаем алгоритм.
6. Если X < C.Key и C имеет потомка слева, то делаем текущим узлом
потомка слева. Переходим к п. 2.
7. Если X < C.Key и C потомка слева не имеет, то создаём левого потомка 
с ключом X и завершаем алгоритм

Такой алгоритм при посл-ти {1, 5, 10, 20, 30} даст вырожденное дерево

!!!Вставка узла в терминальный
узел приводит к вырожденному дереву для 
упорядоченной последовательности.

СЛУЧАЙНОЕ BST: C,R,D - eta(log2N)

- Сложность всех алгоритмов в бинарных деревьях поиска определяется
средневзвешенной глубиной. Операции вставки/удаления могут привести к
дисбалансу и ухудшению средних показателей. Для борьбы с дисбалансом
применяют рандомизацию и балансировку.

- повороты

void rotateRight(node* &head) {
  node *temp = head->left;
  head->left = temp->right;
  temp->right = head;
  head = temp;
}

void rotateLeft(node* &head) {
  node *temp = head->right;
  head->right = temp->left;
  temp->left = head;
  head = temp;
}

ВСТАВКА В КОРЕНЬ
void insert(node* &head, item x) {
  if (head == nullptr) {
    head = new node(x);
    return;
  }
  if (x.key < head->item->key) {
    insert(head->left, x);
    rotateRight(head);
  } else {
    insert(head->right, x);
    rotateLeft(head);
  }
}

!!! Вставка узла в корневой
узел приводит к вырожденному дереву для 
упорядоченной последовательности.

Операция вставки в корень дерева значительно сложнее операции вставки в
терминальный узел, так как она требует O(log N) операций поворота. 
Случайность здесь заключается в том, что для дерева, содержащего N вершин,
мы бросаем кубик, содержащий N + 1 грань, и вставляем в корень 
только при условии, что выпала единица. Другими словами, вставка очередного
узла в корень производится с вероятностью 1/(N+1) , в противном случае 
вставку оставляем обыкновенной, то есть в узел. В этом случае свойства любого
дерева будут соответствовать свойствам СЛУЧАЙНОГО дерева.

= ДЕКАРТОВЫ ДЕРЕВЬЯ
- Случайные бинарные деревья поиска близки к идеальным по 
сложности (H = O(log N)).
Можно внести ещё более серьёзный элемент случайности, 
добавив второй ключ, генерируемый случайно.
- Декартово дерево (treap) есть комбинация бинарного дерева поиска 
(BST) и бинарной кучи (BH). 
При поиске информации декартово дерево — BST. 
Вставка и упорядочивание узлов происходит по отношениям BH.

- Операция find
Декартово дерево есть BST. Поиск происходит по всем 
правилам обычного BST. T(N) = O(log N).

- Операция insert
Декартово дерево есть BST + BH.
Первичная вставка проводится в BST. При этом могут быть 
нарушены свойства BH. Если вставленный элемент не нарушает свойства (BH), то
вставка завершена. Если свойства BH нарушаются, проводится вращение,
поднимающее вставленный элемент. Подъём происходит до тех пор, пока
нарушены свойства (BH) .

- Операция remove
Декартово дерево есть BST + BH.
Так как удаление узлов, отличных от вершин, нетривиально, а удаление
вершин — тривиально, задача — сделать удаляемый узел терминальным.
Для этого на каждом шаге вращаем удаляемый узел с его ребёнком, 
имеющим наибольшее значение y(BH), до тех пор, пока он не станет терминальной
вершиной.

= СБАЛАНСИРОВАННЫЕ деревья поиска
- Поставим более жёсткую задачу: реализовать операции с деревьями,
имеющие время в худшем Θ(log N).

- Сбалансированное дерево №1. 
(идеально сбалансированное дерево A=1)
Для любого узла количество узлов в левом и правом поддереве Nl, Nr
отличается не более, чем на 1. Nr  Nl + 1, Nl  Nr + 1.

- Сбалансированное дерево №2. 
(Примерная сбалансированность количества узлов A=1.71)
Для любого узла количество подузлов в
левом и правом поддеревьях удовлетворяют условиям Nr  2Nl +
1, Nl  2Nr + 1.

- Сбалансированное дерево №3. АВЛ-деревья
(АВЛ-деревья, примерная сбалансированность высот A=1.44)
Для любого узла высоты левого и правого поддеревьев Hl, Hr 
удовлетворяют условиям Hr  Hl + 1, Hl  Hr + 1.

- Сбалансированное дерево №4.  
(Красно-чёрное дерево (RBT), A=2 )
сбалансированное бинарное дерево поиска, которое в 
качестве критерия балансировки использует цвет узлов.
• Вершины разделены на красные и чёрные.
• Каждая вершина хранит поля ключ и значение.
• Каждая вершина имеет указатель left, right, parent.
• Отсутствующие указатели помечаются указателями на фиктивный
узел nil.
• Каждый лист nil — чёрный.
• Если вершина — красная, то её потомки — чёрные.
• Все пути от корня root к листьям содержат одинаковое число чёрных вершин. Это число называется чёрной высотой дерева, black
height, bh(root).

= МНОГОПОТОЧНАЯ работы с CRUD
- Классический способ множественного обращения к одной структуре 
данных — создание критической секции. Теперь при обращении к 
общим данным поток запрашивает вход в критическую секцию, и, 
если доступ разрешён, устанавливается замок на последующие 
входы в критическую секцию. После того, как поток завершил 
изменения структуры данных, замок снимается — и другие потоки 
получают возможность обращения к общим данным. Ну а пока один 
поток захватил замок, другие в это время переходят в состояние 
ожидания. Коэффициент полезного действия системы уменьшается. 
Алгоритмы, использующие критические секции, называются
блокирующими.

-К счастью, имеется возможность увеличить КПД системы, применяя
неблокирующие алгоритмы. Такие алгоритмы используют атомарные 
операции процессора. Существуют машинные команды типа Compare-AndSwap, 
которые позволяют атомарно обменять две ячейки памяти, возможно,
содержащие указатели. При вставке в односвязный список достаточно 
атомарных операций для замены цепочки указателей. Односвязный список —
идеальная структура данных для параллельных неблокирующих операций.

= СПИСКИ С ПРОПУСКАМИ
• Вставка — T(N) = O(log N).
• Поиск — T(N) = O(log N).
• Удаление — T(N) = O(log N).
- Рассмотрим следующую структуру, которая представляет собой
несколько списков, связанных друг с другом тоже списками. 
Каждый следующий список примерно в два раза короче 
предыдущего и пропускает примерно половину элементов 
предыдущего. Каждый элемент, кроме элементов самого нижнего 
уровня, содержит два указателя на элементы — переход на 
следующий уровень и переход на следующий элемент в списке.
На каждом уровне список упорядочен по значению ключа

- Каждый раз при вставке узла на какой-то уровень мы кидаем
монетку. С вероятностью 1/2 мы ничего не вставляем — и на этом операция
завершается. В противном случае вставляем узел на вышележащий уровень
и делаем его текущим. Операция вставки на уровень выше продолжается,
пока позволяет монетка. При необходимости создаются новые вышележащие уровни

- Удаление элемента тоже состоит из двух этапов. 
Вначале ищется удаляемый элемент и помечается столбец, его содержащий 
Затем снизу вверх элемент уделяется из каждой содержащей его строки

= B-дерево
- сбалансированное дерево поиска, узлы которого хранятся во внешней памяти.
1. Каждый узел содержит:
  • количество ключей n, хранящихся в узле;
  • индикатор листа final;
  • n ключей в порядке возрастания;
  • n+1 указатель на детей, если узел не корневой.
2. Ключи есть границы диапазонов ключей в поддеревьях.
3. Все листья расположены на одинаковой глубине h.
4. Вводится показатель t — минимальная степень дерева.
5. В корневом узле — от 1 до 2t-1 ключей.
6. Во внутренних узлах — минимум t-1 ключей.
7. Во внешних узлах — максимум 2t-1 ключей.
8. Заполненный узел имеет 2t-1 ключ.

- Операция find в B-дереве:
1. Операцией бинарного поиска ищем самый левый ключ keyi  k.
2. Если keyi = k, то узел найден.
3. Исполняем Load для дочернего узла и рекурсивно повторяем операцию.
4. Если f inal = true, то ключ не найден.
Количество операций с носителем Tload = O(h) = O(logt N).

- Операция вставки в B-дерево:
1. Операцией find находим узел для вставки.
2. Если лист не заполнен, сохраняя упорядоченность, вставляем ключ.
3. Если лист заполнен (содержит 2t-1 ключей), разбиваем его на два
листа по t-1 ключу поиском медианы.
4. Медиана рекурсивно вставляется в родительский узел.

Сложность в худшем случае: почти заполненный узел на каждом уровне
каждый раз разбивается на два. Тем не менее, количество таких операций
не превосходит высоты дерева Text = O(h) = O(logt n)

= ДЕРЕВО ОТРЕЗКОВ
• многократное нахождение максимального значения на отрезках массива;
• многократное нахождение суммы на отрезке массива.
Попарно соединим соседние вершины, поместив в узел-родитель 
значение функции max(left,right).
операции: коммутаттивные, ассоциативные, имеющие нейтральный элемент
(max, min, xor, +, *, xor)

int n, t[4*MAXN];
void build (int a[], int v, int tl, int tr) {
  if (tl == tr)
    t[v] = a[tl];
  else {
    int tm = (tl + tr) / 2;
    build (a, v*2, tl, tm);
    build (a, v*2+1, tm+1, tr);
    t[v] = t[v*2] + t[v*2+1];
  }
}

int sum (int v, int tl, int tr, int l, int r) {
  if (l > r)
    return 0;
  if (l == tl && r == tr)
    return t[v];
  int tm = (tl + tr) / 2;
  return sum (v*2, tl, tm, l, min(r,tm))
    + sum (v*2+1, tm+1, tr, max(l,tm+1), r);
}

void update (int v, int tl, int tr, int pos, int new_val) {
  if (tl == tr)
    t[v] = new_val;
  else {
    int tm = (tl + tr) / 2;
    if (pos <= tm)
      update (v*2, tl, tm, pos, new_val);
    else
      update (v*2+1, tm+1, tr, pos, new_val);
    t[v] = t[v*2] + t[v*2+1];
  }
}