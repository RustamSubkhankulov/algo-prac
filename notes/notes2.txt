= Жадные алгоритмы состоят из итераций и принимают 
решение на каждом шаге, стараясь найти локально 
оптимальное решение

устроить соревнование между стратегиями —
к сожалению, доказательной силой не обладает. 
Мы можем только показать, что какой-то алгоритм 
на каком-то наборе тестов ведёт себя лучше,
чем другие.

Жадные алгоритмы не заглядывают вперёд. 
Они повторяют локально
оптимальные по какому-либо критерию шаги 
и надеются, что решение
будет глобально оптимальным. Возможно, что 
найдётся такой локально оптимальный критерий — 
и общее решение окажется верным. Это
бывает отнюдь не всегда, но тщательный выбор 
критерия может найти
приемлемое решение.

Префиксным кодом для набора символов 
называетсякод, в котором никакой код 
символа не начинается с другого кода

Задача о кодировании последовательности - 
нахождение оптимальных префиксных кодов
Алгоритм Хаффмана:
Пусть у всех таких терминальных узлов, содержащих 
символы, вес узла определяется как произведение 
встречаемости символа на длину пути до корневого 
узла (глубину узла). Тогда под весом дерева мы 
будем понимать сумму всех весов символов.
Требуется построить дерево, вес которого минимален 
из всех возможных

Оптимальное дерево:
Во-первых, если из какого-то узла исходит 
один путь, то, очевидно,
можно поднять вверх это поддерево, сократив 
на единицу все длины путей
до терминальных вершин,
Во-вторых, пустых терминальных вершин быть 
не должно.
В-третьих, из первых двух пунктов можно 
сделать вывод, что самое
длинное кодовое слово должно быть парным

Задача о покрытии - префиксное дерево О(NK) -> О(N+M)

Z-функция от строки s и позиции p есть длина 
наибольшей подстроки строки s, начинающейся в 
позиции p, совпадающей с
собственным префиксом строки s. - О(N)

vector<int> z_function(string s) {
    int n = (int) s.size();
    vector<int> z(n, 0);
    int l = 0, r = 0;
    for (int i = 1; i < n; i++) {
        // если мы уже видели этот символ
        if (i <= r)
            // то мы можем попробовать его инициализировать z[i - l],
            // но не дальше правой границы: там мы уже ничего не знаем
            z[i] = min(r - i + 1, z[i - l]);
        // дальше каждое успешное увеличение z[i] сдвинет z-блок на единицу
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            z[i]++;
        // проверим, правее ли мы текущего z-блока
        if (i + z[i] - 1 > r) {
            r = i + z[i] - 1;
            l = i;
        }
    }
    return z;
}

OR:

vector<int> z2(string const &s) {
    
    vector<int> ret(s.size());
    
    for (int j = 1, l = 0, r = 0; j < s.size(); j++) {
        
        int p = j > r ? j : j+min(r-j+1,ret[j-l]);

        while (p < s.size() && s[p] == s[p-j])
            p++;
        
        ret[j] = p-j;

        if (p > r) {
            l = j;
            r = p-1;
        }
    }
    return ret;
}