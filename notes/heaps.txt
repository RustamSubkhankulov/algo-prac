= Куча - это специализированная структура данных типа дерево, которая удовлетворяет свойству кучи: если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B). Из этого следует, что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда такие кучи называют max-кучами (в качестве альтернативы, если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами)

Над кучами обычно проводятся следующие операции:

найти максимум или найти минимум: найти максимальный элемент в max-куче или минимальный элемент в min-куче, соответственно
удалить максимум или удалить минимум: удалить корневой узел в max- или min-куче, соответственно
увеличить ключ или уменьшить ключ: обновить ключ в max- или min-куче, соответственно
добавить: добавление нового ключа в кучу.
слияние: соединение двух куч с целью создания новой кучи, содержащей все элементы обеих исходных.


= Двоичная куча - пирамида

Удобная структура данных для сортирующего дерева — массив A, у которого первый элемент, A[1] — элемент в корне, а потомками элемента A[i] являются A[2i] и A[2i+1] (при нумерации элементов с первого). При нумерации элементов с нулевого, корневой элемент — A[0], а потомки элемента A[i] — A[2i+1] и A[2i+2]. При таком способе хранения условия 2 и 3 выполнены автоматически.

- добавить, исключить max, изменить ключ - O(logn)
- make heap - O(n)
- make heap and sort O(nlogn)

- Heapify(A, i) - O(logn)
  left ← 2i
  right ← 2i+1
  heap_size - количество элементов в куче
  largest ← i
  if left ≤ A.heap_size и A[left] > A[largest]
    then largest ← left
  if right ≤ A.heap_size и A[right] > A[largest]
    then largest ← right
  if largest ≠ i
    then Обменять A[i] ↔ A[largest]
         Heapify(A, largest) 

- Build_Heap(A) - O(n)
  A.heap_size ← A.length
  for i ← ⌊A.length/2⌋ downto 1
    do Heapify(A, i)

- HeapSort - O(nlogn)
  Build_Heap(A)
  for i ← A.length downto 1
    do Обменять A[1] ↔ A[i]
       A.heap_size ← A.heap_size-1
       Heapify(A,1)

- Heap_Increase_Key(A, i, key) - O(logn)
  if key < A[i]
    then error "Новый ключ меньше предыдущего"
  A[i] ← key
  while i > 1 и A[⌊i/2⌋] < A[i]
    do Обменять A[i] ↔ A[⌊i/2⌋]
      i ← ⌊i/2⌋

- Heap_Insert(A, key) - O(logn)
  A.heap_size ← A.heap_size+1
  A[A.heap_size] ← -∞
  Heap_Increase_Key(A, A.heap_size, key)

- Heap_Extract_Max(A) - O(logn)
  if A.heap_size[A] < 1
    then error "Куча пуста"
  max ← A[1]
  A[1] ← A[A.heap_size]
  A.heap_size ← A.heap_size-1
  Heapify(A, 1)
  return max

= Биномиальаня куча

- 0 ранг - 1 вершина 
  k ранг - 2^k вершин
  ключ вершины не меньше ключа родителя

- сливаемая куча - две кучи k-1 ранга сливаются 
  подвешиванием одной кучи в качестве k-го ребенка одной к другой

- O(logn): insert, 
           find_min, 
           pop_min, 
           уменьшение значения ключа
           удаление элемента 
           объединение (в общем случае)

